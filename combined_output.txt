CreateApiViewModel.cs

using System;
using System.Diagnostics;
using System.IO;
using System.Threading.Tasks;
using ReactiveUI;
using System.Reactive;

namespace QuickEndpoint.ViewModels;
public class CreateApiViewModel : ViewModelBase
{

    private bool _isCreatingApi;
    public bool IsCreatingApi
    {
        get => _isCreatingApi;
        set => this.RaiseAndSetIfChanged(ref _isCreatingApi, value);
    }

    private string _errorMessage;
    public string ErrorMessage
    {
        get => _errorMessage;
        set => this.RaiseAndSetIfChanged(ref _errorMessage, value);
    }

    private double _createApiProgress;
    public double CreateApiProgress
    {
        get => _createApiProgress;
        set => this.RaiseAndSetIfChanged(ref _createApiProgress, value);
    }

    private string _apiName;
    public string ApiName
    {
        get => _apiName;
        set => this.RaiseAndSetIfChanged(ref _apiName, value);
    }

    private string _nameOfApi;
    public string NameOfApi
    {
        get => _nameOfApi;
        set => this.RaiseAndSetIfChanged(ref _nameOfApi, value);
    }

    private string _descriptionOfApi;
    public string DescriptionOfApi
    {
        get => _descriptionOfApi;
        set => this.RaiseAndSetIfChanged(ref _descriptionOfApi, value);
    }

    // Command property
    public ReactiveCommand<Unit, Unit> CreateApiCommand { get; }

    public CreateApiViewModel()
    {
        // Initialize the command with a method to call
        CreateApiCommand = ReactiveCommand.CreateFromTask(CreateApiAsync);

        // Other initializations...
    }

private async Task CreateApiAsync()
{
    IsCreatingApi = true;
    CreateApiProgress = 0.0;
    LogDebugInfo("Starting API creation process.");

    try
    {
        await InitializeSetupAsync();

        // Setup directories
        var projectDirectory = await SetupProjectDirectoryAsync();
        if (string.IsNullOrEmpty(projectDirectory)) return;

        await CreateProjectAsync(projectDirectory);
        await OverwriteProgramFileAsync(projectDirectory);
        await CreateProjectStructureAsync(projectDirectory);

        LogDebugInfo("API creation process completed successfully.");
    }
    catch (Exception ex)
    {
        LogDebugInfo($"An error occurred during API creation: {ex.Message}");
        ErrorMessage = "An error occurred. Please check the log for details.";
    }
    finally
    {
        IsCreatingApi = false;
        CreateApiProgress = 1.0; // Ensure completion regardless of success.
    }
}

private async Task OverwriteProgramFileAsync(string projectDirectory)
{
    string programCsPath = Path.Combine(projectDirectory, "Program.cs");
    string programCsContent = @"
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllers();

var app = builder.Build();

app.UseHttpsRedirection();
app.MapControllers();

app.Run();
";

    await File.WriteAllTextAsync(programCsPath, programCsContent);
    LogDebugInfo($"Program.cs file overwritten with custom content.");
    CreateApiProgress = 0.6; // Update progress.
}

private async Task<string> SetupProjectDirectoryAsync()
{
    string baseDirectory = Environment.CurrentDirectory;
    string apisDirectory = Path.Combine(baseDirectory, "Data", "CreatedApis");

    Directory.CreateDirectory(apisDirectory); // Ensure the base directory exists.

    string projectDirectory = Path.Combine(apisDirectory, NameOfApi);
    if (Directory.Exists(projectDirectory))
    {
        ErrorMessage = "API with this name already exists.";
        return null;
    }

    Directory.CreateDirectory(projectDirectory);
    LogDebugInfo("Project directory setup completed.");
    await Task.Delay(500); // Simulate directory setup time.
    CreateApiProgress = 0.2;

    return projectDirectory;
}

private async Task CreateProjectAsync(string projectDirectory)
{
    var startInfo = new ProcessStartInfo
    {
        FileName = "dotnet",
        Arguments = "new webapi --no-https",
        WorkingDirectory = projectDirectory,
        RedirectStandardOutput = true,
        RedirectStandardError = true,
        UseShellExecute = false,
        CreateNoWindow = true
    };

    using (var process = new Process { StartInfo = startInfo })
    {
        process.Start();
        await process.WaitForExitAsync();
        CreateApiProgress = 0.5;
        LogDebugInfo("dotnet new webapi process completed.");
    }
}

private async Task CreateProjectStructureAsync(string projectDirectory)
{
    string[] directories = { "Controllers", "Models", "Services", "Repositories" };
    foreach (var dir in directories)
    {
        Directory.CreateDirectory(Path.Combine(projectDirectory, dir));
    }
    LogDebugInfo("Project structure created.");
    await Task.Delay(500); // Simulate structure setup time.
    CreateApiProgress = 0.7;
}

private async Task InitializeSetupAsync()
{
    await Task.Delay(500); // Simulate initial setup work.
    LogDebugInfo("Initial setup completed.");
    CreateApiProgress = 0.1;
}


    private void LogDebugInfo(string message)
    {
        // Append the timestamp to every log entry for better tracking
        string logEntry = $"{DateTime.Now}: {message}\n";
        File.AppendAllText("debug.log", logEntry);
    }
}

DashboardViewModel.cs

using ReactiveUI;
using System;

namespace QuickEndpoint.ViewModels;
    public class DashboardViewModel : ViewModelBase
    {
        private string _apiName;
        public string ApiName
        {
            get => _apiName;
            set => this.RaiseAndSetIfChanged(ref _apiName, value);
        }

        public override string Greeting => "Hello from DashboardViewModel";

    }


EditApiDetailsPathsViewModel.cs

using System.Linq; 
using ReactiveUI;
using Avalonia.Collections;
using System.Reactive;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using System;
using QuickEndpoint.Services; 

namespace QuickEndpoint.ViewModels;

public class Endpoint
{
    public string Name { get; set; }
    public string Method { get; set; }
    public string Path { get; set; }
    public string ApiName { get; set; }
    public string OriginName { get; set; }
}

public class EndpointDisplay
{
    public string Name { get; set; }
    public string Method { get; set; }
    public string Path { get; set; }
    public string DisplayName => $"{Method} {Name} {Path}";
}

public class EditApiDetailsPathsViewModel : ViewModelBase
{
    private AvaloniaList<EndpointDisplay> _availableEndpoints;
    private EndpointDisplay _selectedEndpoint;
    private string _apiName;
    private string _originName;
    private readonly IFileDataService _fileDataService;
    private readonly ILoggerService _logger;

    public string OriginName
    {
        get => _originName;
        set
        {
            this.RaiseAndSetIfChanged(ref _originName, value);
            RefreshApiListAsync().ConfigureAwait(false);
        }
    }
    
    private string _newEndpointPath;
    public string NewEndpointPath
    {
        get => _newEndpointPath;
        set => this.RaiseAndSetIfChanged(ref _newEndpointPath, value);
    }

    private string _newEndpointMethod = "GET";
    public string NewEndpointMethod
    {
        get => _newEndpointMethod;
        set => this.RaiseAndSetIfChanged(ref _newEndpointMethod, value);
    }

    public List<string> HttpMethods { get; } = new List<string> { "GET", "POST", "PUT", "DELETE", "PATCH" };

    public AvaloniaList<EndpointDisplay> AvailableEndpoints
    {
        get => _availableEndpoints;
        set => this.RaiseAndSetIfChanged(ref _availableEndpoints, value);
    }

    public EndpointDisplay SelectedEndpoint
    {
        get => _selectedEndpoint;
        set => this.RaiseAndSetIfChanged(ref _selectedEndpoint, value);
    }

    public string ApiName
    {
        get => _apiName;
        set
        {
            this.RaiseAndSetIfChanged(ref _apiName, value);
            RefreshApiListAsync().ConfigureAwait(false);
        }
    }

    private string _newEndpointName;
    public string NewEndpointName
    {
        get => _newEndpointName;
        set => this.RaiseAndSetIfChanged(ref _newEndpointName, value);
    }

    private string _errorMessage;
    public string ErrorMessage
    {
        get => _errorMessage;
        set => this.RaiseAndSetIfChanged(ref _errorMessage, value);
    }


    public ReactiveCommand<Unit, Unit> RefreshApiListCommand { get; private set; }
    public ReactiveCommand<Unit, Unit> AddEndpointCommand { get; private set; }
    public ReactiveCommand<Unit, Unit> EditSelectedEndpointCommand { get; private set; }
    public ReactiveCommand<Unit, Unit> DeleteSelectedEndpointCommand { get; private set; }
    public ReactiveCommand<Unit, Unit> GoBackToPreviousViewCommand { get; private set; }

 public EditApiDetailsPathsViewModel()
    {
        _fileDataService = new FileDataService();
        _logger = new LoggerService(); 
        RefreshApiListCommand = ReactiveCommand.CreateFromTask(RefreshApiListAsync);
        AddEndpointCommand = ReactiveCommand.CreateFromTask(AddEndpointAsync);
        EditSelectedEndpointCommand = ReactiveCommand.CreateFromTask(EditSelectedEndpointAsync, this.WhenAnyValue((EditApiDetailsPathsViewModel x) => x.SelectedEndpoint, (EndpointDisplay selectedEndpoint) => selectedEndpoint != null));
        DeleteSelectedEndpointCommand = ReactiveCommand.CreateFromTask(DeleteSelectedEndpointAsync, this.WhenAnyValue((EditApiDetailsPathsViewModel x) => x.SelectedEndpoint, (EndpointDisplay selectedEndpoint) => selectedEndpoint != null));

        AvailableEndpoints = new AvaloniaList<EndpointDisplay>();

        GoBackToPreviousViewCommand = ReactiveCommand.Create(GoBackToPreviousView);

        // Automatically refresh the list of endpoints when the ViewModel is created
        RefreshApiListAsync().ConfigureAwait(false);
    }

    private void GoBackToPreviousView()
    {
        MainWindowViewModel.Current.CurrentViewModel = new EditApiDetailsViewModel(_fileDataService, _logger);
    }

    private async Task RefreshApiListAsync()
    {
        var endpoints = await _fileDataService.LoadDataAsync<Endpoint>("endpoints");

        var filteredEndpoints = endpoints
            .Where(endpoint => endpoint.ApiName == ApiName && endpoint.OriginName == OriginName)
            .Select(endpoint => new EndpointDisplay
            { 
                Name = endpoint.Name, 
                Method = endpoint.Method,
                Path = endpoint.Path
            })
            .ToList();

        AvailableEndpoints.Clear();
        foreach (var endpoint in filteredEndpoints)
        {
            AvailableEndpoints.Add(endpoint);
        }
    }

    private async Task AddEndpointAsync()
    {
        _logger.Log($"Starting to add new endpoint: {NewEndpointName}");
        string apiDirectoryPath = Path.Combine(Environment.CurrentDirectory, "Data", "CreatedApis", ApiName);

        if (string.IsNullOrWhiteSpace(NewEndpointName) || string.IsNullOrWhiteSpace(NewEndpointPath))
        {
            ErrorMessage = "Both the name and path of the new endpoint are required.";
            _logger.Log($"Failed to add endpoint due to missing name or path. Name: {NewEndpointName}, Path: {NewEndpointPath}");
            return;
        }

        try
        {
            var endpoints = await _fileDataService.LoadDataAsync<Endpoint>("endpoints");

            var newEndpoint = new Endpoint
            {
                Name = NewEndpointName,
                Method = NewEndpointMethod,
                Path = NewEndpointPath,
                ApiName = ApiName,
                OriginName = OriginName
            };

            endpoints.Add(newEndpoint);
            await _fileDataService.SaveDataAsync("endpoints", endpoints);
            AvailableEndpoints.Add(new EndpointDisplay { Name = newEndpoint.Name, Method = newEndpoint.Method, Path = newEndpoint.Path });
            _logger.Log($"Successfully added new endpoint: {newEndpoint.Name} with method {newEndpoint.Method} and path {newEndpoint.Path}");

            string controllersDirectory = Path.Combine(apiDirectoryPath, "Controllers");
            Directory.CreateDirectory(controllersDirectory);
            string controllerFilePath = Path.Combine(controllersDirectory, $"{newEndpoint.OriginName}Controller.cs");

            if (File.Exists(controllerFilePath))
            {
                string existingControllerCode = await File.ReadAllTextAsync(controllerFilePath);
                // Remove the last two curly braces
                int lastCurlyBraceIndex = existingControllerCode.LastIndexOf("}");
                if (lastCurlyBraceIndex > 0)
                {
                    existingControllerCode = existingControllerCode.Remove(lastCurlyBraceIndex);
                    lastCurlyBraceIndex = existingControllerCode.LastIndexOf("}");
                    if (lastCurlyBraceIndex > 0)
                    {
                        existingControllerCode = existingControllerCode.Remove(lastCurlyBraceIndex);
                    }
                }
                string newEndpointCode = CreateControllerCode(newEndpoint, appendMode: true);
                string updatedControllerCode = existingControllerCode + newEndpointCode + "\n}\n}";
                await File.WriteAllTextAsync(controllerFilePath, updatedControllerCode);
                _logger.Log($"Updated existing controller file at: {controllerFilePath}");
            }
            else
            {
                string controllerCode = CreateControllerCode(newEndpoint, appendMode: false);
                await File.WriteAllTextAsync(controllerFilePath, controllerCode);
                _logger.Log($"Created new controller file at: {controllerFilePath}");
            }

            NewEndpointName = string.Empty;
            NewEndpointPath = string.Empty;
            ErrorMessage = "";
        }
        catch (Exception ex)
        {
            ErrorMessage = "Failed to add the endpoint due to an internal error.";
            _logger.Log($"Exception encountered in AddEndpointAsync: {ex.Message}");
        }
    }


    private string CreateControllerCode(Endpoint endpoint, bool appendMode)
    {
        _logger.Log($"Generating code for endpoint: {endpoint.Name}, Method: {endpoint.Method}, Path: {endpoint.Path}");

        string httpMethodAttribute = endpoint.Method switch
        {
            "POST" => "HttpPost",
            "PUT" => "HttpPut",
            "DELETE" => "HttpDelete",
            "PATCH" => "HttpPatch",
            _ => "HttpGet"
        };

        // Generate a unique method name based on the endpoint path
        string methodName = "Get" + endpoint.Path.Replace("/", string.Empty).Replace("{", string.Empty).Replace("}", string.Empty);

        if (appendMode)
        {
            return $@"
            [{httpMethodAttribute}(""{endpoint.Name}/{endpoint.Path}"")]
            public IActionResult {methodName}()
            {{
                // Logic for {endpoint.Path}
                return Ok(""Response from {endpoint.Path}"");
            }}";
        }
        else
        {
            return $@"
    using Microsoft.AspNetCore.Mvc;

    namespace {endpoint.ApiName}.Controllers
    {{
        [ApiController]
        [Route(""[controller]"")]
        public class {endpoint.OriginName}Controller : ControllerBase
        {{
            [{httpMethodAttribute}(""{endpoint.Name}/{endpoint.Path}"")]
            public IActionResult {methodName}()
            {{
                // Logic for {endpoint.Path}
                return Ok(""Response from {endpoint.Path}"");
            }}
        }}
    }}";
        }
    }



    private async Task EditSelectedEndpointAsync()
    {
        _logger.Log("Starting to edit an endpoint.");
        List<Endpoint> endpoints = await LoadEndpointsAsync();

        var endpointToEdit = endpoints.FirstOrDefault(e => e.Name == SelectedEndpoint.Name && e.ApiName == ApiName && e.OriginName == OriginName);
        if (endpointToEdit != null)
        {
            _logger.Log($"Editing endpoint: {endpointToEdit.Name}, API: {endpointToEdit.ApiName}, Origin: {endpointToEdit.OriginName}");

            endpointToEdit.Method = NewEndpointMethod;
            endpointToEdit.Path = NewEndpointPath;

            await SaveEndpointsAsync(endpoints);
            await RefreshApiListAsync().ConfigureAwait(false);

            _logger.Log($"Successfully edited endpoint: {endpointToEdit.Name}");
        }
        else
        {
            _logger.Log($"No matching endpoint found to edit for Name: {SelectedEndpoint.Name}, API: {ApiName}, Origin: {OriginName}");
        }
    }


    private async Task DeleteSelectedEndpointAsync()
    {
        if (SelectedEndpoint == null)
        {
            _logger.Log("No selected endpoint to delete.");
            return;
        }

        _logger.Log($"Attempting to delete endpoint: {SelectedEndpoint.Name}");
        var endpoints = await _fileDataService.LoadDataAsync<Endpoint>("endpoints");

        var endpointToDelete = endpoints.FirstOrDefault(e => e.Name == SelectedEndpoint.Name && e.ApiName == ApiName && e.OriginName == OriginName);
        if (endpointToDelete != null)
        {
            string controllerFileName = $"{endpointToDelete.OriginName}{endpointToDelete.Name}Controller.cs";
            string controllersDirectory = Path.Combine(Environment.CurrentDirectory, "Data", "CreatedApis", endpointToDelete.ApiName, "Controllers");
            string controllerFilePath = Path.Combine(controllersDirectory, controllerFileName);

            if (File.Exists(controllerFilePath))
            {
                try
                {
                    File.Delete(controllerFilePath);
                    _logger.Log($"Deleted controller file: {controllerFilePath}");
                }
                catch (Exception ex)
                {
                    _logger.Log($"Error deleting controller file '{controllerFileName}': {ex.Message}");
                }
            }

            endpoints.Remove(endpointToDelete);
            await _fileDataService.SaveDataAsync("endpoints", endpoints);

            await RefreshApiListAsync();

            _logger.Log($"Successfully deleted endpoint: {endpointToDelete.Name}");
        }
        else
        {
            _logger.Log($"No matching endpoint found to delete for Name: {SelectedEndpoint.Name}, API: {ApiName}, Origin: {OriginName}");
        }
    }
    private async Task<List<Endpoint>> LoadEndpointsAsync()
    {
        return await _fileDataService.LoadDataAsync<Endpoint>("endpoints");
    }
    private async Task SaveEndpointsAsync(List<Endpoint> endpoints)
    {
        await _fileDataService.SaveDataAsync("endpoints", endpoints);
    }
}

EditApiDetailsViewModel.cs

using System.Linq;
using ReactiveUI;
using Avalonia.Collections;
using System.Reactive;
using System.IO;
using System.Threading.Tasks;
using System;
using System.Collections.Generic; // Add the missing using directive
using QuickEndpoint.Services; // Make sure to include the namespace for FileDataService


namespace QuickEndpoint.ViewModels;

public class Origin
{
    public string OriginName { get; set; }
    public string ApiName { get; set; }
}

public class OriginDisplay
{
    public string OriginName { get; set; }
    public int NumberOfEndpoints { get; set;}
    public string DisplayName => $"{OriginName}, {NumberOfEndpoints}";
}

public class EditApiDetailsViewModel : ViewModelBase
{
    private readonly IFileDataService _fileDataService;
    private readonly ILoggerService _logger;
    private AvaloniaList<OriginDisplay> _availableOrigins = new AvaloniaList<OriginDisplay>();
    private OriginDisplay _selectedOrigin;
    private string _apiName;
    private string _newOriginName;
    private string _errorMessage;

    public AvaloniaList<OriginDisplay> AvailableOrigins
    {
        get => _availableOrigins;
        set => this.RaiseAndSetIfChanged(ref _availableOrigins, value);
    }

    public OriginDisplay SelectedOrigin
    {
        get => _selectedOrigin;
        set
        {
            this.RaiseAndSetIfChanged(ref _selectedOrigin, value);
            SelectedOriginName = value?.OriginName;
        }
    }

    private string _selectedOriginName;
    public string SelectedOriginName
    {
        get => _selectedOriginName;
        set => this.RaiseAndSetIfChanged(ref _selectedOriginName, value);
    }

    public string ApiName
    {
        get => _apiName;
        set
        {
            if (_apiName != value)
            {
                _apiName = value;
                this.RaisePropertyChanged(nameof(ApiName));
                RefreshOriginListCommand.Execute().Subscribe();
            }
        }
    }

    public string NewOriginName
    {
        get => _newOriginName;
        set => this.RaiseAndSetIfChanged(ref _newOriginName, value);
    }

    public string ErrorMessage
    {
        get => _errorMessage;
        set => this.RaiseAndSetIfChanged(ref _errorMessage, value);
    }
    private int _numberOfEndpoints;
    public int NumberOfEndpoints
    {
        get => _numberOfEndpoints;
        set => this.RaiseAndSetIfChanged(ref _numberOfEndpoints, value);
    }


    public ReactiveCommand<Unit, Unit> RefreshOriginListCommand { get; private set; }
    public ReactiveCommand<Unit, Unit> AddOriginCommand { get; private set; }
    public ReactiveCommand<Unit, Unit> EditSelectedOriginCommand { get; private set; }
    public ReactiveCommand<Unit, Unit> DeleteSelectedOriginCommand { get; private set; }
    public ReactiveCommand<Unit, Unit> GoBackToPreviousViewCommand { get; private set; }



    public EditApiDetailsViewModel(IFileDataService fileDataService, ILoggerService logger)
    {
        _fileDataService = fileDataService;
        _logger = logger;
        InitializeCommands();
        RefreshOriginListAsync().ConfigureAwait(false);
    }
    private void InitializeCommands()
    {
        RefreshOriginListCommand = ReactiveCommand.CreateFromTask(RefreshOriginListAsync);
        AddOriginCommand = ReactiveCommand.CreateFromTask(AddOriginAsync);
        EditSelectedOriginCommand = ReactiveCommand.CreateFromTask(EditSelectedOriginAsync, this.WhenAnyValue((EditApiDetailsViewModel x) => x.SelectedOrigin, (OriginDisplay selectedOrigin) => selectedOrigin != null));
        DeleteSelectedOriginCommand = ReactiveCommand.CreateFromTask(DeleteSelectedOriginAsync, this.WhenAnyValue((EditApiDetailsViewModel x) => x.SelectedOrigin, (OriginDisplay selectedOrigin) => selectedOrigin != null));
        AvailableOrigins = new AvaloniaList<OriginDisplay>();

        GoBackToPreviousViewCommand = ReactiveCommand.Create(GoBackToPreviousView);
    }
    private void GoBackToPreviousView()
    {
        MainWindowViewModel.Current.CurrentViewModel = new EditApiViewModel();
    }

    private async Task RefreshOriginListAsync()
    {
        var origins = await _fileDataService.LoadDataAsync<Origin>("origins");
        var filteredOrigins = origins
            .Where(origin => origin.ApiName == ApiName)
            .GroupBy(origin => origin.OriginName)
            .ToList();

        var tempOrigins = new List<OriginDisplay>();
        foreach (var group in filteredOrigins)
        {
            int numberOfEndpoints = await CountEndpointsAsync(group.Key);
            var originDisplay = new OriginDisplay
            {
                OriginName = group.Key,
                NumberOfEndpoints = numberOfEndpoints
            };
            tempOrigins.Add(originDisplay);
        }

        AvailableOrigins = new AvaloniaList<OriginDisplay>(tempOrigins);
    }



    private async Task AddOriginAsync()
    {
        string apiDirectoryPath = Path.Combine(Environment.CurrentDirectory, "Data", "CreatedApis", ApiName);

        await _logger.LogAsync($"Dodawanie nowego pochodzenia: {NewOriginName}");
        // Check if the Origin name is provided
        if (string.IsNullOrWhiteSpace(NewOriginName))
        {
            ErrorMessage = "The name of the new Origin is required.";
            await _logger.LogAsync("Nie podano nazwy nowego pochodzenia.");
            return;
        }

        // Use FileDataService to load existing origins
        var origins = await _fileDataService.LoadDataAsync<Origin>("origins");

        // Check if an Origin with the same name already exists within the API
        if (origins.Any(origin => origin.OriginName.Equals(NewOriginName, StringComparison.OrdinalIgnoreCase) && origin.ApiName == ApiName))
        {
            ErrorMessage = "An Origin with this name already exists within the API. Please use a different name.";
            return;
        }

        ErrorMessage = ""; // Clear the error message if all checks pass

        // Create a new Origin instance
        var newOrigin = new Origin
        {
            OriginName = NewOriginName,
            ApiName = ApiName
        };

        // Add the new Origin to the list
        origins.Add(newOrigin);

        // Use FileDataService to save the updated list of Origins
        await _fileDataService.SaveDataAsync("origins", origins);

        // Update the UI to reflect the new Origin
        AvailableOrigins.Add(new OriginDisplay { OriginName = newOrigin.OriginName });
        await _logger.LogAsync($"Nowe pochodzenie dodane pomyślnie: {NewOriginName}");
        NewOriginName = ""; // Reset the input fields for the next addition
        await RefreshOriginListAsync();
    }


    private async Task EditSelectedOriginAsync()
    {
        // Assuming you have a way to pass or set ApiName in EditApiDetailsPathsViewModel,
        // otherwise just instantiate it directly.
        var editApiDetailsPathsViewModel = new EditApiDetailsPathsViewModel
        {
            // Set properties as needed, for example:
            ApiName = this.ApiName,
            OriginName = this.SelectedOriginName
        };

        // Update the current ViewModel in MainWindowViewModel
        MainWindowViewModel.Current.CurrentViewModel = editApiDetailsPathsViewModel;
    }


    private async Task DeleteSelectedOriginAsync()
    {
        if (SelectedOrigin != null)
        {
            // Use FileDataService to load existing origins
            var origins = await _fileDataService.LoadDataAsync<Origin>("origins");

            var originToDelete = origins.FirstOrDefault(o => o.OriginName == SelectedOrigin.OriginName);
            if (originToDelete != null)
            {
                // Delete associated endpoints first
                await DeleteAssociatedEndpointsAsync(originToDelete.OriginName);

                // Now remove the origin from the origins list
                origins.Remove(originToDelete);

                // Use FileDataService to save the updated list of Origins
                await _fileDataService.SaveDataAsync("origins", origins);

                // Refresh the list of available origins in the UI
                await RefreshOriginListAsync();
            }
        }
    }

    private async Task DeleteAssociatedEndpointsAsync(string originName)
    {
        // Use FileDataService to load existing endpoints
        var endpoints = await _fileDataService.LoadDataAsync<Endpoint>("endpoints"); 

        // Identify endpoints associated with the origin
        var endpointsToDelete = endpoints.Where(endpoint => endpoint.OriginName == originName).ToList();

        foreach (var endpoint in endpointsToDelete)
        {
            // Construct the controller file path for each endpoint
            string controllerFileName = $"{endpoint.OriginName}{endpoint.Name}Controller.cs";
            string controllersDirectory = Path.Combine(Environment.CurrentDirectory, "Data", "CreatedApis", endpoint.ApiName, "Controllers");
            string controllerFilePath = Path.Combine(controllersDirectory, controllerFileName);

            if (File.Exists(controllerFilePath))
            {
                try
                {
                    File.Delete(controllerFilePath); // Attempt to delete the controller file
                }
                catch (Exception ex)
                {
                    Console.Error.WriteLine($"Error deleting controller file for '{endpoint.Name}': {ex.Message}");
                    // Optionally, log this error or handle it as needed
                }
            }
        }

        // Filter out and update the endpoints list after deletion
        endpoints = endpoints.Except(endpointsToDelete).ToList();

        // Use FileDataService to save the updated list of endpoints
        await _fileDataService.SaveDataAsync("endpoints", endpoints);
    }

    private async Task<int> CountEndpointsAsync(string originName)
    {
        var endpoints = await _fileDataService.LoadDataAsync<Endpoint>("endpoints");
        _logger.Log($"Loaded {endpoints.Count} endpoints:");

        foreach (var endpoint in endpoints)
        {
            _logger.Log($"Endpoint: {endpoint.Name}, Origin: {endpoint.OriginName}");
        }

        return endpoints.Count(endpoint => endpoint.OriginName == originName);
    }
}

EditApiViewModel.cs

using ReactiveUI;
using System;
using System.IO;
using System.Linq;
using System.Reactive;
using Avalonia.Collections;
using QuickEndpoint.Services;

namespace QuickEndpoint.ViewModels;
public class EditApiViewModel : ViewModelBase
{
    private string _apiName;
    private AvaloniaList<string> _availableApis = new AvaloniaList<string>();
    public ReactiveCommand<Unit, Unit> EditApiCommand { get; }
    public ReactiveCommand<Unit, Unit> RefreshApiListCommand { get; }

    public string ApiName
    {
        get => _apiName;
        set => this.RaiseAndSetIfChanged(ref _apiName, value);
    }

    public AvaloniaList<string> AvailableApis
    {
        get => _availableApis;
        set => this.RaiseAndSetIfChanged(ref _availableApis, value);
    }

        public EditApiViewModel()
        {
            EditApiCommand = ReactiveCommand.Create(EditApi);
            RefreshApiListCommand = ReactiveCommand.Create(RefreshAvailableApis);

            // Initial refresh to populate available APIs.
            RefreshAvailableApis(); 
        }


        private void EditApi()
        {
            var editDetailsViewModel = new EditApiDetailsViewModel(new FileDataService(), new LoggerService())
            {
                ApiName = this.ApiName // Passing the ApiName to the new ViewModel.
            };
            
            // Now, you would set this ViewModel to be the current one shown in the MainWindow or the relevant container.
            MainWindowViewModel.Current.CurrentViewModel = editDetailsViewModel;
        }


        public void RefreshAvailableApis()
        {
            try
            {
                LogDebugInfo("Starting to refresh available APIs...");

                string apisDirectory = Path.Combine(Directory.GetCurrentDirectory(), "Data", "CreatedApis");
                LogDebugInfo($"Looking for APIs in directory: {apisDirectory}");

                if (Directory.Exists(apisDirectory))
                {
                    var apiDirectories = Directory.GetDirectories(apisDirectory).Select(Path.GetFileName).ToList();
                    
                    LogDebugInfo($"Found {apiDirectories.Count} API directories.");
                    
                    AvailableApis.Clear();
                    foreach (var dir in apiDirectories)
                    {
                        AvailableApis.Add(dir);
                        LogDebugInfo($"Added API directory to list: {dir}");
                    }
                }
                else
                {
                    LogDebugInfo("APIs directory does not exist.");
                }

                LogDebugInfo("Finished refreshing available APIs.");
            }
            catch (Exception ex)
            {
                LogDebugInfo($"An error occurred while refreshing available APIs: {ex.Message}");
            }
        }

        private void LogDebugInfo(string message)
        {
            // Ensure the debug log file path is correct and accessible.
            string logFilePath = Path.Combine(Directory.GetCurrentDirectory(), "debug.log");

            // Append the timestamp to every log entry for better tracking.
            string logEntry = $"{DateTime.Now}: {message}\n";
            File.AppendAllText(logFilePath, logEntry);
        }
    }

MainWindowViewModel.cs

﻿using ReactiveUI;
using System.Reactive;

namespace QuickEndpoint.ViewModels
{
    using QuickEndpoint.Services; // Zapewnij właściwe użycie

    public class MainWindowViewModel : ReactiveObject
    {
        private readonly NavigationService _navigationService;
        public ReactiveCommand<Unit, Unit> CreateApiCommand { get; }
        public ReactiveCommand<Unit, Unit> EditApiCommand { get; }
        public ReactiveCommand<Unit, Unit> PublishApiCommand { get; }
        public ReactiveCommand<Unit, Unit> OpenSettingsCommand { get; }

        // Usunięto inicjalizację _current wewnątrz gettera Current
        private static MainWindowViewModel _current = new MainWindowViewModel();
        public static MainWindowViewModel Current => _current;

        private ViewModelBase _currentViewModel;
        public ViewModelBase CurrentViewModel
        {
            get => _currentViewModel;
            set => this.RaiseAndSetIfChanged(ref _currentViewModel, value);
        }

        

        // Zmieniony konstruktor, aby nie inicjować _current wewnątrz niego
        private MainWindowViewModel()
        {
            _navigationService = new NavigationService(this);

            CreateApiCommand = ReactiveCommand.Create(() => _navigationService.NavigateTo<CreateApiViewModel>());
            EditApiCommand = ReactiveCommand.Create(() => _navigationService.NavigateTo<EditApiViewModel>());
            PublishApiCommand = ReactiveCommand.Create(() => _navigationService.NavigateTo<PublishApiViewModel>());
            OpenSettingsCommand = ReactiveCommand.Create(() => _navigationService.NavigateTo<OpenSettingsViewModel>());

            _navigationService.NavigateTo<DashboardViewModel>();
        }

        // Metoda do inicjalizacji Current z zewnątrz
        public static void InitializeCurrent()
        {
            if (_current == null)
            {
                _current = new MainWindowViewModel();
            }
        }
    }
}


OpenSettingsViewModel.cs

using Avalonia;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Markup.Xaml.Styling;
using Avalonia.Styling;
using ReactiveUI;
using System;

namespace QuickEndpoint.ViewModels;
    public class OpenSettingsViewModel : ViewModelBase
    {
        private bool _isDarkThemeEnabled;

        // Property to track if dark theme is enabled
        public bool IsDarkThemeEnabled
        {
            get => _isDarkThemeEnabled;
            set
            {
                this.RaiseAndSetIfChanged(ref _isDarkThemeEnabled, value);
                ApplyTheme(value);
            }
        }

        private void ApplyTheme(bool useDarkTheme)
        {
            // Construct the URI for the theme resource
            var themeUri = useDarkTheme ? 
                "avares://QuickEndpoint/Themes/DarkTheme.axaml" :
                "avares://QuickEndpoint/Themes/LightTheme.axaml";

            var theme = new StyleInclude(new Uri(themeUri))
            {
                Source = new Uri(themeUri)
            };

            if (Application.Current.ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
            {
                // Assuming there is a main window and its styles can be manipulated
                desktop.MainWindow.Styles.Clear();
                desktop.MainWindow.Styles.Add(theme);
            }
        }
    }


PublishApiViewModel.cs

using System;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reactive;
using Avalonia.Collections;
using ReactiveUI;
using QuickEndpoint_MainApp.Modules;
using System.Threading.Tasks;

namespace QuickEndpoint.ViewModels
{
    public class PublishApiViewModel : ViewModelBase
    {
        private string _apiName;
        private AvaloniaList<string> _availableApis = new AvaloniaList<string>();
        public ReactiveCommand<Unit, Unit> PublishApiCommand { get; }
        public ReactiveCommand<Unit, Unit> RefreshApiListCommand { get; }

        private bool _isPublishingApi;
        public bool IsPublishingApi
        {
            get => _isPublishingApi;
            set => this.RaiseAndSetIfChanged(ref _isPublishingApi, value);
        }

        private double _publishApiProgress;
        public double publishApiProgress
        {
            get => _publishApiProgress;
            set => this.RaiseAndSetIfChanged(ref _publishApiProgress, value);
        }

        public string ApiName
        {
            get => _apiName;
            set => this.RaiseAndSetIfChanged(ref _apiName, value);
        }

        public AvaloniaList<string> AvailableApis
        {
            get => _availableApis;
            set => this.RaiseAndSetIfChanged(ref _availableApis, value);
        }
        public string ApiName1 { get => _apiName; set => _apiName = value; }
        public AvaloniaList<string> AvailableApis1 { get => _availableApis; set => _availableApis = value; }
        public bool IsPublishingApi1 { get => _isPublishingApi; set => _isPublishingApi = value; }
        public double PublishApiProgress { get => _publishApiProgress; set => _publishApiProgress = value; }

        public PublishApiViewModel()
        {
            PublishApiCommand = ReactiveCommand.CreateFromTask(PublishApiAsync);
            RefreshApiListCommand = ReactiveCommand.Create(RefreshAvailableApis);

            // Initial refresh to populate available APIs.
            RefreshAvailableApis();
        }

        private async Task PublishApiAsync()
        {
            if (string.IsNullOrEmpty(ApiName))
            {
                LogDebugInfo("No API selected for publishing.");
                return;
            }

            try
            {
                IsPublishingApi = true;
                LogDebugInfo("PublishApi method execution started.");

                // Step 1: Setup directories
                await Task.Delay(250);
                publishApiProgress = 0; // Indicate initial setup is starting

                string baseDirectory = Environment.CurrentDirectory;
                string sourceProjectDir = Path.Combine(baseDirectory, "Data", "CreatedApis", ApiName);
                string publishedApisDir = Path.Combine(baseDirectory, "Data", "PublishedApis", ApiName);
                string toolsDir = Path.Combine(baseDirectory, "Data", "Tools", "nssm", "win64");
                Directory.CreateDirectory(publishedApisDir);
                LogDebugInfo("Directories setup completed.");

                // Step 2: Publish the API
                await Task.Delay(500);
                publishApiProgress = 0.4; // Indicate publishing starts

                string configuration = "Release";
                ApplicationPublisher.PublishApplication(sourceProjectDir, publishedApisDir, configuration, LogDebugInfo);
                LogDebugInfo("API published.");

                // Step 3: Copy necessary tools
                await Task.Delay(500);
                publishApiProgress = 0.6; // Publishing completed
                string nssmSourcePath = Path.Combine(toolsDir, "nssm.exe");
                string nssmDestinationPath = Path.Combine(publishedApisDir, "nssm.exe");
                if (File.Exists(nssmSourcePath))
                {
                    File.Copy(nssmSourcePath, nssmDestinationPath, overwrite: true);
                    LogDebugInfo("nssm.exe has been copied to the published API directory.");
                }
                else
                {
                    LogDebugInfo("nssm.exe was not found in the tools directory.");
                }

                // Step 4: Generate install and uninstall scripts
                await Task.Delay(500);
                publishApiProgress = 0.8; // Tool copy completed

                InstallerScriptGenerator.GenerateBatchInstallScript(ApiName, publishedApisDir, LogDebugInfo);
                InstallerScriptGenerator.GenerateBatchUninstallScript(ApiName, publishedApisDir, LogDebugInfo);
                LogDebugInfo($"Scripts for '{ApiName}' generated.");

                // Setp 5: Finalize the process
                publishApiProgress = 1.0; // Update progress to 100% after completion
                await Task.Delay(500);

                LogDebugInfo("API publishing process completed.");
            }
            catch (Exception ex)
            {
                LogDebugInfo($"An error occurred while publishing API '{ApiName}': {ex.Message}");
            }
            finally
            {
                IsPublishingApi = false;
            }
        }



        public void RefreshAvailableApis()
        {
            try
            {
                string apisDirectory = Path.Combine(Directory.GetCurrentDirectory(), "Data", "CreatedApis");
                if (Directory.Exists(apisDirectory))
                {
                    var apiDirectories = Directory.GetDirectories(apisDirectory).Select(Path.GetFileName).ToList();
                    AvailableApis.Clear();
                    AvailableApis.AddRange(apiDirectories);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"An error occurred while refreshing available APIs: {ex.Message}");
            }
        }

        private void LogDebugInfo(string message)
        {
            // Append the timestamp to every log entry for better tracking
            string logEntry = $"{DateTime.Now}: {message}\n";
            File.AppendAllText("debug.log", logEntry);
        }
    }
}

namespace QuickEndpoint_MainApp.Modules
{

    public static class ApplicationPublisher
    {
        public static void PublishApplication(string projectDir, string publishDir, string configuration, Action<string> logger)
        {
            Utilities.ExecuteProcess("dotnet", $"publish \"{projectDir}\" -c {configuration} -o \"{publishDir}\"", logger);
            logger($"The application has been published to {publishDir}");
        }
    }

    public static class InstallerScriptGenerator
    {
        public static void GenerateBatchInstallScript(string appName, string directory, Action<string> logger)
        {
            string installScriptPath = Path.Combine(directory, "install.bat");
            string batchContent = @$"@echo off
                                  echo Installing {appName}...
                                  REM Example command to install service using NSSM and current directory for paths
                                  cd /d %~dp0
                                  nssm.exe install {appName} ""%~dp0{appName}.exe""
                                  echo Installation completed.
                                  pause";

            File.WriteAllText(installScriptPath, batchContent);
            logger($"Install script has been saved at: {installScriptPath}");
        }

        public static void GenerateBatchUninstallScript(string appName, string directory, Action<string> logger)
        {
            string uninstallScriptPath = Path.Combine(directory, "uninstall.bat");
            string batchContent = @$"@echo off
                                  echo Uninstalling {appName}...
                                  REM Example command to uninstall service using NSSM
                                  cd /d %~dp0
                                  nssm.exe remove {appName} confirm
                                  echo Uninstallation completed.
                                  pause";

            File.WriteAllText(uninstallScriptPath, batchContent);
            logger($"Uninstall script has been saved at: {uninstallScriptPath}");
        }
    }


    public static class Utilities
    {
        public static string GetProjectBaseDirectory()
        {
            var currentDir = Directory.GetCurrentDirectory();
            return Directory.GetParent(currentDir)?.FullName ?? throw new InvalidOperationException("Cannot find the parent directory.");
        }

        public static void EnsureDirectoryExists(string path)
        {
            if (!Directory.Exists(path))
            {
                Directory.CreateDirectory(path);
            }
        }

        public static void ExecuteProcess(string fileName, string arguments, Action<string> logger)
        {
            using var process = Process.Start(new ProcessStartInfo
            {
                FileName = fileName,
                Arguments = arguments,
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                UseShellExecute = false,
                CreateNoWindow = true
            });

            var output = process.StandardOutput.ReadToEnd();
            var error = process.StandardError.ReadToEnd();

            process.WaitForExit();

            if (!string.IsNullOrEmpty(output))
            {
                logger(output);
            }

            if (!string.IsNullOrEmpty(error))
            {
                logger("Error: " + error);
            }

            if (process.ExitCode != 0)
            {
                throw new InvalidOperationException($"Process exited with code: {process.ExitCode}. Error: {output}");
            }
        }
    }
}


ViewModelBase.cs

﻿using ReactiveUI;

namespace QuickEndpoint.ViewModels;

public class ViewModelBase : ReactiveObject
{
    public virtual string Greeting => "Hello from Base ViewModel";
}


CreateApiView.axaml

<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:vm="clr-namespace:QuickEndpoint.ViewModels"
             xmlns:c="clr-namespace:QuickEndpoint.Converters"
             x:Class="QuickEndpoint.Views.CreateApiView"
             HorizontalAlignment="Stretch"
             VerticalAlignment="Stretch"
             x:CompileBindings="True"
             x:DataType="vm:CreateApiViewModel">

    <UserControl.Resources>
        <c:BooleanToVisibilityConverter x:Key="BooleanToVisibilityConverter"/>
    </UserControl.Resources>

    <UserControl.Styles>
        <Style Selector="TextBlock.H1">
            <Setter Property="FontSize" Value="20"/>
            <Setter Property="FontWeight" Value="Bold"/>
            <Setter Property="Margin" Value="0,16,0,10"/> <!-- Adjusted margin to add space below -->
            <Setter Property="HorizontalAlignment" Value="Center"/> <!-- Center alignment -->
        </Style>
        <Style Selector="TextBox">
            <Setter Property="Margin" Value="0,10,0,0"/>
            <Setter Property="Width" Value="250"/>
            <Setter Property="HorizontalAlignment" Value="Center"/>
        </Style>
        <Style Selector="Button">
            <Setter Property="Margin" Value="20,20,20,0"/> <!-- Adjusted margin for symmetry -->
            <Setter Property="Padding" Value="10"/>
            <Setter Property="FontSize" Value="16"/>
            <Setter Property="CornerRadius" Value="5"/>
            <Setter Property="Width" Value="300"/>
            <Setter Property="HorizontalAlignment" Value="Center"/>
        </Style>
        <Style Selector="ProgressBar">
            <Setter Property="Margin" Value="20,20,20,0"/> <!-- Adjusted margin for symmetry -->
            <Setter Property="Height" Value="20"/>
            <Setter Property="Maximum" Value="1"/>
            <Setter Property="Width" Value="300"/>
            <Setter Property="HorizontalAlignment" Value="Center"/>
        </Style>
    </UserControl.Styles>

    <Grid VerticalAlignment="Center" HorizontalAlignment="Center">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="Auto"/> <!-- For the Name pair -->
            <ColumnDefinition Width="20"/>  <!-- Margin between the pairs -->
            <ColumnDefinition Width="Auto"/> <!-- For the Description pair -->
        </Grid.ColumnDefinitions>

        <!-- Name Pair -->
        <StackPanel Grid.Row="0" Grid.Column="0" HorizontalAlignment="Center">
            <TextBlock Text="Name" Classes="H1"/>
            <TextBox Text="{Binding NameOfApi, Mode=TwoWay}" x:DataType="vm:CreateApiViewModel"/>
        </StackPanel>

        <!-- Description Pair -->
        <StackPanel Grid.Row="0" Grid.Column="2" HorizontalAlignment="Center">
            <TextBlock Text="Description" Classes="H1"/>
            <TextBox Text="{Binding DescriptionOfApi, Mode=TwoWay}" x:DataType="vm:CreateApiViewModel"/>
        </StackPanel>

        <!-- Create API Button -->
        <Button Grid.Row="1" Grid.Column="0" Grid.ColumnSpan="3"
                Command="{Binding CreateApiCommand}" Content="Create API" x:DataType="vm:CreateApiViewModel"/>

        <!-- ProgressBar -->
        <ProgressBar Grid.Row="2" Grid.Column="0" Grid.ColumnSpan="3"
                     IsVisible="{Binding IsCreatingApi}" 
                     Value="{Binding CreateApiProgress, Mode=OneWay}" x:DataType="vm:CreateApiViewModel"/>

        <!-- Error Message -->
        <TextBlock Grid.Row="3" Grid.Column="0" Grid.ColumnSpan="3"
                   Text="{Binding ErrorMessage, Mode=OneWay}" 
                   TextWrapping="Wrap" Foreground="Red" FontWeight="Bold" x:DataType="vm:CreateApiViewModel"/>
    </Grid>
</UserControl>


CreateApiView.axaml.cs

using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using QuickEndpoint.ViewModels;

namespace QuickEndpoint.Views
{
    public partial class CreateApiView : UserControl
    {
        public CreateApiView()
        {
            InitializeComponent();
            DataContext = new CreateApiViewModel();
        }

        private void InitializeComponent()
        {
            AvaloniaXamlLoader.Load(this);
        }
    }
}


DashboardView.axaml

<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="QuickEndpoint.Views.DashboardView">
    

        <UserControl.Styles>
            <Style Selector="TextBlock.H1">
            <Setter Property="FontSize" Value="24"/>
            <Setter Property="FontWeight" Value="Bold"/>
            <Setter Property="TextAlignment" Value="Center"/>
            <Setter Property="Margin" Value="0,10"/>
            </Style>
            <Style Selector="TextBlock.H2">
            <Setter Property="FontSize" Value="16"/>
            <Setter Property="TextAlignment" Value="Center"/>
            <Setter Property="Margin" Value="0,10"/>
            </Style>
        </UserControl.Styles>
    
        <StackPanel HorizontalAlignment="Center" VerticalAlignment="Center">
            <TextBlock HorizontalAlignment="Center" VerticalAlignment="Center" Classes="H1">Welcome to the QuickEndpoint</TextBlock>
            <TextBlock HorizontalAlignment="Center" VerticalAlignment="Center" Classes="H2" Text="Start creating your own API!"/>
        </StackPanel>
        
</UserControl>


DashboardView.axaml.cs

using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using QuickEndpoint.ViewModels;

namespace QuickEndpoint.Views
{
    public partial class DashboardView : UserControl
    {
        public DashboardView()
        {
            InitializeComponent();
            DataContext = new DashboardViewModel();
        }

        private void InitializeComponent()
        {
            AvaloniaXamlLoader.Load(this);
        }
    }
}


EditApiDetailsPathsView.axaml

<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="QuickEndpoint.Views.EditApiDetailsPathsView"
             HorizontalAlignment="Stretch"
             VerticalAlignment="Stretch"
             xmlns:vm="clr-namespace:QuickEndpoint.ViewModels"
             x:CompileBindings="True">
    <Grid Margin="20">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/> <!-- Dla tytułu "Endpoints of the API" -->
            <RowDefinition Height="Auto"/> <!-- Dla nazwy API -->
            <RowDefinition Height="Auto"/> <!-- Dla formularza dodawania nowego endpointa -->
            <RowDefinition Height="*"/>    <!-- Dla listy endpointów -->
            <RowDefinition Height="Auto"/> <!-- Dla przycisków akcji -->
            <RowDefinition Height="Auto"/> <!-- Dla przycisków akcji -->
        </Grid.RowDefinitions>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="400"/> <!-- Fixed width for the form area -->
            <ColumnDefinition Width="2"/>   <!-- Separator width -->
            <ColumnDefinition Width="*"/>   <!-- Remaining space for the list -->
        </Grid.ColumnDefinitions>

        <!-- Separator -->
        <Border Grid.Row="0" Grid.RowSpan="5" Grid.Column="1" Background="LightGray" Width="2" Margin="0,10"/>

        <!-- Tytuł "Endpoints of the API" wyświetlany w prawym górnym rogu -->
        <TextBlock Grid.Row="0" Grid.Column="0" Grid.ColumnSpan="3" Text="Endpoints of the API Origin" FontSize="24" FontWeight="Bold" Margin="0,10,0,20" HorizontalAlignment="Right" VerticalAlignment="Top"/>

        <!-- Horizontal Separator -->
        <Border Grid.Row="1" Grid.Column="1" Grid.ColumnSpan="3" Background="LightGray" Height="2" Margin="10,45,0,0"/>

        <!-- Nazwa API -->
        <TextBlock Grid.Row="1" Grid.Column="2" Text="{Binding OriginName}" Foreground="#FFC107" FontSize="18" FontWeight="Bold" HorizontalAlignment="Right" Margin="0,0,20,10" VerticalAlignment="Top" x:DataType="vm:EditApiDetailsPathsViewModel"/>

        <!-- Formularz dodawania nowego endpointa -->
        <StackPanel Grid.Row="2" Grid.Column="0" Margin="0,10,20,10">
            <TextBox Watermark="Enter new endpoint name" Width="360" Text="{Binding NewEndpointName, Mode=TwoWay}" x:DataType="vm:EditApiDetailsPathsViewModel"/>
            <TextBox Watermark="Enter endpoint path" Width="360" Text="{Binding NewEndpointPath, Mode=TwoWay}" Margin="0,10,0,0" x:DataType="vm:EditApiDetailsPathsViewModel"/>
            <ComboBox Width="360" Margin="0,10,0,0" SelectedItem="{Binding NewEndpointMethod, Mode=TwoWay}" ItemsSource="{Binding HttpMethods}" x:DataType="vm:EditApiDetailsPathsViewModel"/>
            <Button Content="Add New Endpoint" Width="360" Margin="0,10,0,0" Command="{Binding AddEndpointCommand}" x:DataType="vm:EditApiDetailsPathsViewModel"/>
            <TextBlock Text="{Binding ErrorMessage}" Foreground="Red" FontWeight="Bold" Width="360" TextWrapping="Wrap" Margin="0,10,0,0" x:DataType="vm:EditApiDetailsPathsViewModel"/>
        </StackPanel>

        <!-- Przyciski akcji -->
        <UniformGrid Grid.Row="4" Grid.Column="0" Rows="1" Columns="2" Margin="0,10,20,10">
            <Button Content="Edit Selected" Width="170" Margin="5,0" Command="{Binding EditSelectedEndpointCommand}" x:DataType="vm:EditApiDetailsPathsViewModel"/>
            <Button Content="Delete Selected" Width="170" Command="{Binding DeleteSelectedEndpointCommand}" x:DataType="vm:EditApiDetailsPathsViewModel"/>
        </UniformGrid>

        <UniformGrid Grid.Row="5" Grid.Column="0" Rows="1" Columns="1" Margin="0,10,20,10">
            <Button Content="Go Back" Width="360" Margin="0,10,0,0" Command="{Binding GoBackToPreviousViewCommand}" HorizontalAlignment="Stretch" x:DataType="vm:EditApiDetailsPathsViewModel"/>
        </UniformGrid>


        <!-- Lista endpointów -->
        <ListBox Grid.Row="2" Grid.RowSpan="3" Grid.Column="2" Margin="20,10,20,10" ItemsSource="{Binding AvailableEndpoints}" SelectedItem="{Binding SelectedEndpoint}" x:DataType="vm:EditApiDetailsPathsViewModel">
            <ListBox.ItemTemplate>
                <DataTemplate>
                    <Grid>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="Auto"/>
                            <ColumnDefinition Width="*"/>
                            <ColumnDefinition Width="Auto"/>
                            <ColumnDefinition Width="Auto"/>
                        </Grid.ColumnDefinitions>
                        <TextBlock Grid.Column="0" Text="{Binding Method}" FontWeight="Bold" Foreground="#FFC107"/>
                        <TextBlock Grid.Column="1" Text="{Binding Name}" Margin="5,0,5,0"/>
                        <TextBlock Grid.Column="2" Text="Endpoint path:" FontStyle="Italic" Foreground="DarkGray" HorizontalAlignment="Right"/>
                        <TextBlock Grid.Column="3" Text="{Binding Path}" FontStyle="Italic" Foreground="DarkGray" Margin="5,0,0,0"/>
                    </Grid>
                </DataTemplate>
            </ListBox.ItemTemplate>
        </ListBox>




    </Grid>
</UserControl>


EditApiDetailsPathsView.axaml.cs

using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using QuickEndpoint.ViewModels;

namespace QuickEndpoint.Views
{
    public partial class EditApiDetailsPathsView : UserControl
    {
        public EditApiDetailsPathsView()
        {
            InitializeComponent();
            DataContext = new EditApiDetailsPathsViewModel();
        }

        private void InitializeComponent()
        {
            AvaloniaXamlLoader.Load(this);
        }
    }
}


EditApiDetailsView.axaml

<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="QuickEndpoint.Views.EditApiDetailsView"
             HorizontalAlignment="Stretch"
             VerticalAlignment="Stretch"
             xmlns:vm="clr-namespace:QuickEndpoint.ViewModels"
             x:CompileBindings="True">
    <Grid Margin="20">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/> <!-- Dla tytułu "Endpoints of the API" -->
            <RowDefinition Height="Auto"/> <!-- Dla nazwy API -->
            <RowDefinition Height="Auto"/> <!-- Dla formularza dodawania nowego endpointa -->
            <RowDefinition Height="*"/>    <!-- Dla listy endpointów -->
            <RowDefinition Height="Auto"/> <!-- Dla przycisków akcji -->
            <RowDefinition Height="Auto"/> <!-- Dla przycisków akcji -->
        </Grid.RowDefinitions>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="400"/> <!-- Fixed width for the form area -->
            <ColumnDefinition Width="2"/>   <!-- Separator width -->
            <ColumnDefinition Width="*"/>   <!-- Remaining space for the list -->
        </Grid.ColumnDefinitions>

        <!-- Separator -->
        <Border Grid.Row="0" Grid.RowSpan="5" Grid.Column="1" Background="LightGray" Width="2" Margin="0,10"/>

        <!-- Tytuł "Origins of the API" wyświetlany w prawym górnym rogu -->
        <TextBlock Grid.Row="0" Grid.Column="0" Grid.ColumnSpan="3" Text="Origins of the API" FontSize="24" FontWeight="Bold" Margin="0,10,0,20" HorizontalAlignment="Right" VerticalAlignment="Top"/>

        <!-- Horizontal Separator -->
        <Border Grid.Row="1" Grid.Column="1" Grid.ColumnSpan="3" Background="LightGray" Height="2" Margin="10,45,0,0"/>

        <!-- Nazwa API -->
        <TextBlock Grid.Row="1" Grid.Column="2" Text="{Binding ApiName}" Foreground="#FFC107" FontSize="18" FontWeight="Bold" HorizontalAlignment="Right" Margin="0,0,20,10" VerticalAlignment="Top" x:DataType="vm:EditApiDetailsViewModel"/>

        <!-- Formularz dodawania nowego Origina -->
        <StackPanel Grid.Row="2" Grid.Column="0" Margin="0,10,20,10">
            <TextBox Watermark="Enter new origin name" Width="360" Text="{Binding NewOriginName, Mode=TwoWay}" x:DataType="vm:EditApiDetailsViewModel"/>
            <Button Content="Add New Origin" Width="360" Margin="0,10,0,0" Command="{Binding AddOriginCommand}" x:DataType="vm:EditApiDetailsViewModel"/>
            <TextBlock Text="{Binding ErrorMessage}" Foreground="Red" FontWeight="Bold" Width="360" TextWrapping="Wrap" Margin="0,10,0,0" x:DataType="vm:EditApiDetailsViewModel"/>
        </StackPanel>

        <!-- Przyciski akcji -->
        <UniformGrid Grid.Row="4" Grid.Column="0" Rows="1" Columns="2" Margin="0,10,20,10">
            <Button Content="Edit Selected" Width="170" Margin="5,0" Command="{Binding EditSelectedOriginCommand}" x:DataType="vm:EditApiDetailsViewModel"/>
            <Button Content="Delete Selected" Width="170" Command="{Binding DeleteSelectedOriginCommand}" x:DataType="vm:EditApiDetailsViewModel"/>
        </UniformGrid>

        <UniformGrid Grid.Row="5" Grid.Column="0" Rows="1" Columns="1" Margin="0,10,20,10">
            <Button Content="Go Back" Width="360" Margin="0,10,0,0" Command="{Binding GoBackToPreviousViewCommand}" HorizontalAlignment="Stretch" x:DataType="vm:EditApiDetailsViewModel"/>
        </UniformGrid>

        <!-- Lista Originów -->
        <ListBox Grid.Row="2" Grid.RowSpan="3" Grid.Column="2" Margin="20,10,20,10" ItemsSource="{Binding AvailableOrigins}" SelectedItem="{Binding SelectedOrigin}" x:DataType="vm:EditApiDetailsViewModel">
            <ListBox.ItemTemplate>
                <DataTemplate>
                    <Grid>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="Auto"/>
                            <ColumnDefinition Width="*"/>
                            <ColumnDefinition Width="Auto"/>
                            <ColumnDefinition Width="Auto"/>
                        </Grid.ColumnDefinitions>
                        <TextBlock Grid.Column="1" Text="{Binding OriginName}" Margin="5,0,5,0"/>
                        <TextBlock Grid.Column="2" Text="{Binding NumberOfEndpoints, StringFormat='({0} endpoints)'}" Foreground="Gray" Margin="5,0,5,0"/>                    </Grid>
                </DataTemplate>
            </ListBox.ItemTemplate>
        </ListBox>




    </Grid>
</UserControl>


EditApiDetailsView.cs

using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using QuickEndpoint.ViewModels;
using QuickEndpoint.Services; // Add this using directive

namespace QuickEndpoint.Views

{
    public partial class EditApiDetailsView : UserControl
    {
        public EditApiDetailsView()
        {
            InitializeComponent();
            DataContext = new EditApiDetailsViewModel(new FileDataService(), new LoggerService());
        }

        private void InitializeComponent()
        {
            AvaloniaXamlLoader.Load(this);
        }
    }
}


EditApiView.axaml

<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="QuickEndpoint.Views.EditApiView"
             xmlns:vm="clr-namespace:QuickEndpoint.ViewModels"
             x:CompileBindings="True"
             HorizontalAlignment="Center"
             VerticalAlignment="Center">
    
    <UserControl.DataContext>
        <vm:EditApiViewModel/>
    </UserControl.DataContext>

    <UserControl.Styles>
        <Style Selector="TextBlock.H1">
            <Setter Property="FontSize" Value="24"/>
            <Setter Property="FontWeight" Value="Bold"/>
            <Setter Property="TextAlignment" Value="Center"/>
            <Setter Property="Margin" Value="0,10"/>
        </Style>
        <Style Selector="TextBlock.H2">
            <Setter Property="FontSize" Value="16"/>
            <Setter Property="TextAlignment" Value="Center"/>
            <Setter Property="Margin" Value="0,10"/>
        </Style>
    </UserControl.Styles>

    <!-- Outer Grid to Center the Content Vertically -->
    <Grid VerticalAlignment="Center" HorizontalAlignment="Center">
        <Border VerticalAlignment="Center" HorizontalAlignment="Center">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/> <!-- Title "Edit API" -->
                    <RowDefinition Height="Auto"/> <!-- ComboBox -->
                    <RowDefinition Height="Auto"/> <!-- Buttons Panel -->
                </Grid.RowDefinitions>

                <!-- Title "Edit API" -->
                <TextBlock Grid.Row="0" Classes="H1" Text="Edit API" Margin="10" />

                <!-- ComboBox -->
                <ComboBox Grid.Row="1" Name="Select" Margin="10" HorizontalAlignment="Center" 
                          ItemsSource="{Binding AvailableApis}" SelectedItem="{Binding ApiName}" x:DataType="vm:EditApiViewModel"  
                          Width="290" Classes="H1">
                    <ComboBox.ItemTemplate>
                        <DataTemplate>
                            <TextBlock Text="{Binding}"/>
                        </DataTemplate>
                    </ComboBox.ItemTemplate>
                </ComboBox>

                <!-- Buttons Panel -->
                <StackPanel Grid.Row="2" Orientation="Horizontal" HorizontalAlignment="Center">
                    <Button Content="Edit Selected API" Classes="H2" Command="{Binding EditApiCommand}" Margin="10" x:DataType="vm:EditApiViewModel"/>
                    <Button Content="Refresh API List" Classes="H2" Command="{Binding RefreshApiListCommand}" Margin="10" x:DataType="vm:EditApiViewModel"/>
                </StackPanel>
            </Grid>
        </Border>
    </Grid>
</UserControl>


EditApiView.axaml.cs

using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using QuickEndpoint.ViewModels;

namespace QuickEndpoint.Views
{
    public partial class EditApiView : UserControl
    {
        public EditApiView()
        {
            InitializeComponent();
            DataContext = new EditApiViewModel();
        }

        private void InitializeComponent()
        {
            AvaloniaXamlLoader.Load(this);
        }
    }
}


MainWindow.axaml

<Window xmlns="https://github.com/avaloniaui"
       xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
       xmlns:vm="clr-namespace:QuickEndpoint.ViewModels"
       xmlns:v="clr-namespace:QuickEndpoint.Views"
       x:Class="QuickEndpoint.Views.MainWindow"
       Icon="/Assets/avalonia-logo.ico"
       Title="QuickEndpoint"
       x:CompileBindings="True"
       xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
       d:DesignWidth="800" d:DesignHeight="450">

  <Design.DataContext>
    <vm:MainWindowViewModel/>
  </Design.DataContext>

  <DockPanel>
    <Menu DockPanel.Dock="Bottom">
      <MenuItem Header="API">
        <MenuItem Header="Create API" Command="{Binding CreateApiCommand}" x:DataType="vm:MainWindowViewModel"/>
        <MenuItem Header="Edit API" Command="{Binding EditApiCommand}" x:DataType="vm:MainWindowViewModel"/>
        <MenuItem Header="Publish API" Command="{Binding PublishApiCommand}" x:DataType="vm:MainWindowViewModel"/>
      </MenuItem>
      <MenuItem Header="Settings" Command="{Binding OpenSettingsCommand}" x:DataType="vm:MainWindowViewModel"/>
    </Menu>

    <Grid DockPanel.Dock="Right">
      <ContentControl Content="{Binding CurrentViewModel}" x:DataType="vm:MainWindowViewModel" HorizontalContentAlignment="Stretch" VerticalContentAlignment="Stretch">

      </ContentControl>
    </Grid>
  </DockPanel>

</Window>


MainWindow.axaml.cs

using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using QuickEndpoint.ViewModels;

namespace QuickEndpoint.Views
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
            // Usuwamy bezpośrednie tworzenie nowej instancji MainWindowViewModel
            // i zamiast tego korzystamy z już zainicjalizowanej instancji.
            DataContext = MainWindowViewModel.Current;
        }

        private void InitializeComponent()
        {
            AvaloniaXamlLoader.Load(this);
        }
    }
}


OpenSettingsView.axaml

<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="QuickEndpoint.Views.OpenSettingsView"
             xmlns:vm="clr-namespace:QuickEndpoint.ViewModels"
             xmlns:c="clr-namespace:QuickEndpoint.Converters"
             x:CompileBindings="True">

    <UserControl.DataContext>
        <vm:OpenSettingsViewModel/>
    </UserControl.DataContext>

    <UserControl.Resources>
        <c:BooleanToVisibilityConverter x:Key="BooleanToThemeConverter"/>
    </UserControl.Resources>

    <StackPanel Orientation="Vertical" HorizontalAlignment="Center" VerticalAlignment="Center">
        <!-- Theme Toggle Switch -->
        <TextBlock Text="Theme:" VerticalAlignment="Center" Margin="0,0,10,0"/>
        <ToggleButton IsChecked="{Binding IsDarkThemeEnabled, Mode=TwoWay}" 
                      Content="{Binding IsDarkThemeEnabled, Converter={StaticResource BooleanToThemeConverter}}"
                      HorizontalAlignment="Center"
                      x:DataType="vm:OpenSettingsViewModel"/>
    </StackPanel>
</UserControl>


OpenSettingsView.axaml.cs

using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using QuickEndpoint.ViewModels;

namespace QuickEndpoint.Views
{
    public partial class OpenSettingsView : UserControl
    {
        public OpenSettingsView()
        {
            InitializeComponent();
            DataContext = new OpenSettingsViewModel();
        }

        private void InitializeComponent()
        {
            AvaloniaXamlLoader.Load(this);
        }
    }
}


PublishApiView.axaml

<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="QuickEndpoint.Views.PublishApiView"
             xmlns:vm="clr-namespace:QuickEndpoint.ViewModels"
             xmlns:c="clr-namespace:QuickEndpoint.Converters"
             x:CompileBindings="True"
             HorizontalAlignment="Center"
             VerticalAlignment="Center">


    <UserControl.DataContext>
        <vm:PublishApiViewModel/>
    </UserControl.DataContext>

    <UserControl.Resources>
        <c:BooleanToVisibilityConverter x:Key="BooleanToVisibilityConverter"/>
    </UserControl.Resources>

    <UserControl.Styles>
        <Style Selector="TextBlock.H1">
            <Setter Property="FontSize" Value="24"/>
            <Setter Property="FontWeight" Value="Bold"/>
            <Setter Property="TextAlignment" Value="Center"/>
            <Setter Property="Margin" Value="0,10"/>
        </Style>
        <Style Selector="TextBlock.H2">
            <Setter Property="FontSize" Value="16"/>
            <Setter Property="TextAlignment" Value="Center"/>
            <Setter Property="Margin" Value="0,10"/>
        </Style>
    </UserControl.Styles>

<Grid VerticalAlignment="Center" HorizontalAlignment="Center">
    <Grid.RowDefinitions>
        <RowDefinition Height="Auto"/> <!-- Title "Edit API" -->
        <RowDefinition Height="Auto"/> <!-- ComboBox -->
        <RowDefinition Height="Auto"/> <!-- Buttons Panel -->
    </Grid.RowDefinitions>

    <!-- Title "Edit API" -->
    <TextBlock Grid.Row="0"
               Classes="H1"  
               Text="Publish API"
               Margin="10"
               FontSize="20"
               HorizontalAlignment="Center"/>

    <!-- ComboBox -->
    <ComboBox Grid.Row="1"
              Name="Select"
              Margin="10"
              HorizontalAlignment="Center"
              ItemsSource="{Binding AvailableApis}"
              x:DataType="vm:PublishApiViewModel"
              SelectedItem="{Binding ApiName}"
              Width="310"
              Classes="H1">
        <ComboBox.ItemTemplate>
            <DataTemplate>
                <TextBlock Text="{Binding}"/>
            </DataTemplate>
        </ComboBox.ItemTemplate>
    </ComboBox>

    <StackPanel Grid.Row="2" Orientation="Horizontal" HorizontalAlignment="Center">
        <Button Content="Publish Selected API"
                Classes="H2"
                x:DataType="vm:PublishApiViewModel"
                Command="{Binding PublishApiCommand}"
                Margin="10"/>
        <Button Content="Refresh API List"
                Classes="H2"
                x:DataType="vm:PublishApiViewModel"
                Command="{Binding RefreshApiListCommand}"
                Margin="10"/>
    </StackPanel>

    <ProgressBar Grid.Row="5"
                 IsVisible="{Binding IsPublishingApi}"
                 x:DataType="vm:PublishApiViewModel"
                 Value="{Binding publishApiProgress, Mode=OneWay}"
                 Height="20"
                 Maximum="1"
                 Margin="0,25,0,0"/>
</Grid>

</UserControl>



PublishApiView.axaml.cs

using Avalonia.Controls;
using Avalonia.Markup.Xaml;
using QuickEndpoint.ViewModels;

namespace QuickEndpoint.Views
{
    public partial class PublishApiView : UserControl
    {
        public PublishApiView()
        {
            InitializeComponent();
            DataContext = new PublishApiViewModel();
        }

        private void InitializeComponent()
        {
            AvaloniaXamlLoader.Load(this);
        }
    }
}


